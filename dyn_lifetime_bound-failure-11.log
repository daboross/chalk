
running 0 tests

test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out


running 1 test
DEBUG trait_datum=TraitDatum { id: TraitId(#0), binders: for[type] TraitDatumBound { where_clauses: [] }, flags: TraitFlags { auto: false, marker: false, upstream: false, fundamental: false, non_enumerable: false, coinductive: false }, associated_ty_ids: [], well_known: None }
DEBUG trait_datum=TraitDatum { id: TraitId(#1), binders: for[type, type] TraitDatumBound { where_clauses: [] }, flags: TraitFlags { auto: false, marker: false, upstream: false, fundamental: false, non_enumerable: false, coinductive: false }, associated_ty_ids: [], well_known: None }
lower_impl{impl_id=ImplId(#2)}
  0ms DEBUG trait_ref=SeparatorTraitRef(?)
  0ms DEBUG where_clauses=SeparatorTraitRef(?)
  0ms DEBUG associated_ty_value_ids=[]
perform_orphan_check{impl_id=ImplId(#2)}
  0ms DEBUG impl_datum=ImplDatum { polarity: Positive, binders: for<type> ImplDatumBound { trait_ref: ^0.0 as Eq<^0.0>, where_clauses: [] }, impl_type: Local, associated_ty_value_ids: [] }
  canonicalize{message=InEnvironment {
      environment: Env([]),
      goal: ForAll<type> { LocalImplAllowed(^0.0: Eq<^0.0>) },
  }}
  u_canonicalize{message=Canonical {
      value: InEnvironment {
          environment: Env([]),
          goal: ForAll<type> { LocalImplAllowed(^0.0: Eq<^0.0>) },
      },
      binders: [],
  }}
  get_or_create_table_for_ucanonical_goal{goal=UCanonical { canonical: Canonical { value: InEnvironment { environment: Env([]), goal: ForAll<type> { LocalImplAllowed(^0.0: Eq<^0.0>) } }, binders: [] }, universes: 1 }}
    0ms INFO creating new table with goal = UCanonical {
        canonical: Canonical {
            value: InEnvironment {
                environment: Env([]),
                goal: ForAll<type> { LocalImplAllowed(^0.0: Eq<^0.0>) },
            },
            binders: [],
        },
        universes: 1,
    }, table=TableIndex(0)
    0ms DEBUG created new universe: U1
    0ms INFO pushing initial strand, ex_clause=ExClause { subst: [], ambiguous: false, constraints: [], subgoals: [Positive(InEnvironment { environment: Env([]), goal: LocalImplAllowed(!1_0: Eq<!1_0>) })], delayed_subgoals: [], answer_time: TimeStamp { clock: 0 }, floundered_subgoals: [] }
    canonicalize{message=ExClause {
        subst: [],
        ambiguous: false,
        constraints: [],
        subgoals: [
            Positive(
                InEnvironment {
                    environment: Env([]),
                    goal: LocalImplAllowed(!1_0: Eq<!1_0>),
                },
            ),
        ],
        delayed_subgoals: [],
        answer_time: TimeStamp {
            clock: 0,
        },
        floundered_subgoals: [],
    }}
  ensure_root_answer{initial_table=TableIndex(0), initial_answer=AnswerIndex(0)}
    0ms INFO table goal = UCanonical {
        canonical: Canonical {
            value: InEnvironment {
                environment: Env([]),
                goal: ForAll<type> { LocalImplAllowed(^0.0: Eq<^0.0>) },
            },
            binders: [],
        },
        universes: 1,
    }
    0ms DEBUG starting next strand = Strand {
        ex_clause: ExClause {
            subst: [],
            ambiguous: false,
            constraints: [],
            subgoals: [
                Positive(
                    InEnvironment {
                        environment: Env([]),
                        goal: LocalImplAllowed(!1_0: Eq<!1_0>),
                    },
                ),
            ],
            delayed_subgoals: [],
            answer_time: TimeStamp {
                clock: 0,
            },
            floundered_subgoals: [],
        },
        selected_subgoal: None,
    }
    get_or_create_table_for_subgoal{subgoal=Positive(InEnvironment { environment: Env([]), goal: LocalImplAllowed(!1_0: Eq<!1_0>) })}
      canonicalize{message=InEnvironment {
          environment: Env([]),
          goal: LocalImplAllowed(!1_0: Eq<!1_0>),
      }}
      u_canonicalize{message=Canonical {
          value: InEnvironment {
              environment: Env([]),
              goal: LocalImplAllowed(!1_0: Eq<!1_0>),
          },
          binders: [],
      }}
      0ms DEBUG ucanonical_subgoal=UCanonical { canonical: Canonical { value: InEnvironment { environment: Env([]), goal: LocalImplAllowed(!1_0: Eq<!1_0>) }, binders: [] }, universes: 2 }, universe_map=UniverseMap { universes: [U0, U1] }
      get_or_create_table_for_ucanonical_goal{goal=UCanonical { canonical: Canonical { value: InEnvironment { environment: Env([]), goal: LocalImplAllowed(!1_0: Eq<!1_0>) }, binders: [] }, universes: 2 }}
        0ms INFO creating new table with goal = UCanonical {
            canonical: Canonical {
                value: InEnvironment {
                    environment: Env([]),
                    goal: LocalImplAllowed(!1_0: Eq<!1_0>),
                },
                binders: [],
            },
            universes: 2,
        }, table=TableIndex(1)
        0ms DEBUG created new universe: U1
        program_clauses_for_goal{environment=Env([]), goal=LocalImplAllowed(!1_0: Eq<!1_0>), binders=[]}
          program_clauses_that_could_match{goal=LocalImplAllowed(!1_0: Eq<!1_0>), binders=[]}
            push_binders{binders=for<type, type> []}
              0ms DEBUG value=[]
              0ms DEBUG pushed clause Some(for<type, type> WellFormed(^0.0: Eq<^0.1>) :- Implemented(^0.0: Eq<^0.1>))
              0ms DEBUG pushed clause Some(for<type, type> LocalImplAllowed(^0.0: Eq<^0.1>))
              0ms DEBUG pushed clause Some(for<type, type> Implemented(^0.0: Eq<^0.1>) :- FromEnv(^0.0: Eq<^0.1>))
          0ms DEBUG clauses=[for<type, type> LocalImplAllowed(^0.0: Eq<^0.1>)]
        0ms INFO program clause = for<type, type> LocalImplAllowed(^0.0: Eq<^0.1>)
        resolvent_clause{db=ChalkDatabase { }, goal=LocalImplAllowed(!1_0: Eq<!1_0>), clause=for<type, type> LocalImplAllowed(^0.0: Eq<^0.1>)}
          0ms DEBUG created new variable, var=?0, ui=U1
          0ms DEBUG created new variable, var=?1, ui=U1
          0ms DEBUG consequence=LocalImplAllowed(?0: Eq<?1>), conditions=(), constraints=[]
          relate{variance=Invariant, a=LocalImplAllowed(!1_0: Eq<!1_0>), b=LocalImplAllowed(?0: Eq<?1>)}
            relate{variance=Invariant, a=LocalImplAllowed(!1_0: Eq<!1_0>), b=LocalImplAllowed(?0: Eq<?1>)}
              0ms DEBUG zip_tys Invariant, !1_0, ?0
              relate_ty_ty{variance=Invariant, a=!1_0, b=?0}
                relate_var_ty{var=?0, ty=!1_0}
                  0ms DEBUG relate_var_ty: universe index of var: U1
                  0ms DEBUG trying fold_with on !1_0
                  0ms DEBUG just generalizing to the ty itself: !1_0
                  0ms DEBUG var ?0 generalized to !1_0
                  0ms DEBUG var ?0 set to !1_0
                  relate_ty_ty{variance=Invariant, a=!1_0, b=!1_0}
                  0ms DEBUG generalized var !1_0 related to !1_0
              0ms DEBUG zip_tys Invariant, !1_0, ?1
              relate_ty_ty{variance=Invariant, a=!1_0, b=?1}
                relate_var_ty{var=?1, ty=!1_0}
                  0ms DEBUG relate_var_ty: universe index of var: U1
                  0ms DEBUG trying fold_with on !1_0
                  0ms DEBUG just generalizing to the ty itself: !1_0
                  0ms DEBUG var ?1 generalized to !1_0
                  0ms DEBUG var ?1 set to !1_0
                  relate_ty_ty{variance=Invariant, a=!1_0, b=!1_0}
                  0ms DEBUG generalized var !1_0 related to !1_0
        2ms INFO pushing initial strand with ex-clause: ExClause {
            subst: [],
            ambiguous: false,
            constraints: [],
            subgoals: [],
            delayed_subgoals: [],
            answer_time: TimeStamp {
                clock: 0,
            },
            floundered_subgoals: [],
        }
        canonicalize{message=ExClause {
            subst: [],
            ambiguous: false,
            constraints: [],
            subgoals: [],
            delayed_subgoals: [],
            answer_time: TimeStamp {
                clock: 0,
            },
            floundered_subgoals: [],
        }}
    3ms DEBUG table selection TableIndex(1) with goal: UCanonical { canonical: Canonical { value: InEnvironment { environment: Env([]), goal: LocalImplAllowed(!1_0: Eq<!1_0>) }, binders: [] }, universes: 2 }, subgoal_table=TableIndex(1), goal=UCanonical { canonical: Canonical { value: InEnvironment { environment: Env([]), goal: LocalImplAllowed(!1_0: Eq<!1_0>) }, binders: [] }, universes: 2 }
    3ms DEBUG created new universe: U1
    3ms DEBUG created new universe: U1
    3ms DEBUG starting next strand = Strand {
        ex_clause: ExClause {
            subst: [],
            ambiguous: false,
            constraints: [],
            subgoals: [],
            delayed_subgoals: [],
            answer_time: TimeStamp {
                clock: 0,
            },
            floundered_subgoals: [],
        },
        selected_subgoal: None,
    }
    3ms DEBUG no remaining subgoals for the table
    canonicalize{message=AnswerSubst {
        subst: [],
        constraints: [],
        delayed_subgoals: [],
    }}
    3ms DEBUG found answer, table=TableIndex(1), subst=Canonical { value: AnswerSubst { subst: [], constraints: [], delayed_subgoals: [] }, binders: [] }, floundered=false
    push_answer{answer=Answer { subst: Canonical { value: AnswerSubst { subst: [], constraints: [], delayed_subgoals: [] }, binders: [] }, ambiguous: false }}
      0ms DEBUG pre-existing entry: None
      0ms INFO new answer to table, goal=UCanonical { canonical: Canonical { value: InEnvironment { environment: Env([]), goal: LocalImplAllowed(!1_0: Eq<!1_0>) }, binders: [] }, universes: 2 }, answer=Answer { subst: Canonical { value: AnswerSubst { subst: [], constraints: [], delayed_subgoals: [] }, binders: [] }, ambiguous: false }
    3ms DEBUG answer is available
    3ms DEBUG starting next strand = Strand {
        ex_clause: ExClause {
            subst: [],
            ambiguous: false,
            constraints: [],
            subgoals: [
                Positive(
                    InEnvironment {
                        environment: Env([]),
                        goal: LocalImplAllowed(!1_0: Eq<!1_0>),
                    },
                ),
            ],
            delayed_subgoals: [],
            answer_time: TimeStamp {
                clock: 0,
            },
            floundered_subgoals: [],
        },
        selected_subgoal: Some(
            SelectedSubgoal {
                subgoal_index: 0,
                subgoal_table: TableIndex(1),
                answer_index: AnswerIndex(0),
                universe_map: UniverseMap {
                    universes: [
                        U0,
                        U1,
                    ],
                },
            },
        ),
    }
    3ms DEBUG table selection TableIndex(1) with goal: UCanonical { canonical: Canonical { value: InEnvironment { environment: Env([]), goal: LocalImplAllowed(!1_0: Eq<!1_0>) }, binders: [] }, universes: 2 }, subgoal_table=TableIndex(1), goal=UCanonical { canonical: Canonical { value: InEnvironment { environment: Env([]), goal: LocalImplAllowed(!1_0: Eq<!1_0>) }, binders: [] }, universes: 2 }
    3ms INFO answer cached = Answer { subst: Canonical { value: AnswerSubst { subst: [], constraints: [], delayed_subgoals: [] }, binders: [] }, ambiguous: false }
    map_from_canonical{canonical_value=Canonical { value: InEnvironment { environment: Env([]), goal: LocalImplAllowed(!1_0: Eq<!1_0>) }, binders: [] }, universes=[U0, U1]}
    map_from_canonical{canonical_value=Canonical { value: AnswerSubst { subst: [], constraints: [], delayed_subgoals: [] }, binders: [] }, universes=[U0, U1]}
    apply_answer_subst{unification_database=ChalkDatabase { }, ex_clause=ExClause { subst: [], ambiguous: false, constraints: [], subgoals: [], delayed_subgoals: [], answer_time: TimeStamp { clock: 0 }, floundered_subgoals: [] }, selected_goal=InEnvironment { environment: Env([]), goal: LocalImplAllowed(!1_0: Eq<!1_0>) }, answer_table_goal=Canonical { value: InEnvironment { environment: Env([]), goal: LocalImplAllowed(!1_0: Eq<!1_0>) }, binders: [] }, canonical_answer_subst=Canonical { value: AnswerSubst { subst: [], constraints: [], delayed_subgoals: [] }, binders: [] }}
      0ms DEBUG selected_goal=InEnvironment { environment: Env([]), goal: LocalImplAllowed(!1_0: Eq<!1_0>) }
    4ms DEBUG merged answer into current strand, strand=Strand { ex_clause: ExClause { subst: [], ambiguous: false, constraints: [], subgoals: [], delayed_subgoals: [], answer_time: TimeStamp { clock: 1 }, floundered_subgoals: [] }, selected_subgoal: None }
    4ms DEBUG starting next strand = Strand {
        ex_clause: ExClause {
            subst: [],
            ambiguous: false,
            constraints: [],
            subgoals: [],
            delayed_subgoals: [],
            answer_time: TimeStamp {
                clock: 1,
            },
            floundered_subgoals: [],
        },
        selected_subgoal: None,
    }
    4ms DEBUG no remaining subgoals for the table
    canonicalize{message=AnswerSubst {
        subst: [],
        constraints: [],
        delayed_subgoals: [],
    }}
    4ms DEBUG found answer, table=TableIndex(0), subst=Canonical { value: AnswerSubst { subst: [], constraints: [], delayed_subgoals: [] }, binders: [] }, floundered=false
    push_answer{answer=Answer { subst: Canonical { value: AnswerSubst { subst: [], constraints: [], delayed_subgoals: [] }, binders: [] }, ambiguous: false }}
      0ms DEBUG pre-existing entry: None
      0ms INFO new answer to table, goal=UCanonical { canonical: Canonical { value: InEnvironment { environment: Env([]), goal: ForAll<type> { LocalImplAllowed(^0.0: Eq<^0.0>) } }, binders: [] }, universes: 1 }, answer=Answer { subst: Canonical { value: AnswerSubst { subst: [], constraints: [], delayed_subgoals: [] }, binders: [] }, ambiguous: false }
    4ms DEBUG answer is available
  5ms DEBUG answer=CompleteAnswer { subst: Canonical { value: ConstrainedSubst { subst: [], constraints: [] }, binders: [] }, ambiguous: false }
  ensure_root_answer{initial_table=TableIndex(0), initial_answer=AnswerIndex(1)}
    0ms INFO table goal = UCanonical {
        canonical: Canonical {
            value: InEnvironment {
                environment: Env([]),
                goal: ForAll<type> { LocalImplAllowed(^0.0: Eq<^0.0>) },
            },
            binders: [],
        },
        universes: 1,
    }
    0ms DEBUG no more strands available (or all cycles) for TableIndex(0)
    0ms DEBUG no more strands available
    0ms DEBUG no more solutions
  5ms DEBUG overlaps = true
DEBUG input_types=[]
DEBUG WF trait goal: ForAll<type> { if ([]) { WellFormed(^0.0: Eq<^0.0>) } }
canonicalize{message=InEnvironment {
    environment: Env([]),
    goal: ForAll<type> { if ([]) { WellFormed(^0.0: Eq<^0.0>) } },
}}
u_canonicalize{message=Canonical {
    value: InEnvironment {
        environment: Env([]),
        goal: ForAll<type> { if ([]) { WellFormed(^0.0: Eq<^0.0>) } },
    },
    binders: [],
}}
get_or_create_table_for_ucanonical_goal{goal=UCanonical { canonical: Canonical { value: InEnvironment { environment: Env([]), goal: ForAll<type> { if ([]) { WellFormed(^0.0: Eq<^0.0>) } } }, binders: [] }, universes: 1 }}
  0ms INFO creating new table with goal = UCanonical {
      canonical: Canonical {
          value: InEnvironment {
              environment: Env([]),
              goal: ForAll<type> { if ([]) { WellFormed(^0.0: Eq<^0.0>) } },
          },
          binders: [],
      },
      universes: 1,
  }, table=TableIndex(0)
  0ms DEBUG created new universe: U1
  0ms INFO pushing initial strand, ex_clause=ExClause { subst: [], ambiguous: false, constraints: [], subgoals: [Positive(InEnvironment { environment: Env([]), goal: WellFormed(!1_0: Eq<!1_0>) })], delayed_subgoals: [], answer_time: TimeStamp { clock: 0 }, floundered_subgoals: [] }
  canonicalize{message=ExClause {
      subst: [],
      ambiguous: false,
      constraints: [],
      subgoals: [
          Positive(
              InEnvironment {
                  environment: Env([]),
                  goal: WellFormed(!1_0: Eq<!1_0>),
              },
          ),
      ],
      delayed_subgoals: [],
      answer_time: TimeStamp {
          clock: 0,
      },
      floundered_subgoals: [],
  }}
ensure_root_answer{initial_table=TableIndex(0), initial_answer=AnswerIndex(0)}
  0ms INFO table goal = UCanonical {
      canonical: Canonical {
          value: InEnvironment {
              environment: Env([]),
              goal: ForAll<type> { if ([]) { WellFormed(^0.0: Eq<^0.0>) } },
          },
          binders: [],
      },
      universes: 1,
  }
  0ms DEBUG starting next strand = Strand {
      ex_clause: ExClause {
          subst: [],
          ambiguous: false,
          constraints: [],
          subgoals: [
              Positive(
                  InEnvironment {
                      environment: Env([]),
                      goal: WellFormed(!1_0: Eq<!1_0>),
                  },
              ),
          ],
          delayed_subgoals: [],
          answer_time: TimeStamp {
              clock: 0,
          },
          floundered_subgoals: [],
      },
      selected_subgoal: None,
  }
  get_or_create_table_for_subgoal{subgoal=Positive(InEnvironment { environment: Env([]), goal: WellFormed(!1_0: Eq<!1_0>) })}
    canonicalize{message=InEnvironment {
        environment: Env([]),
        goal: WellFormed(!1_0: Eq<!1_0>),
    }}
    u_canonicalize{message=Canonical {
        value: InEnvironment {
            environment: Env([]),
            goal: WellFormed(!1_0: Eq<!1_0>),
        },
        binders: [],
    }}
    0ms DEBUG ucanonical_subgoal=UCanonical { canonical: Canonical { value: InEnvironment { environment: Env([]), goal: WellFormed(!1_0: Eq<!1_0>) }, binders: [] }, universes: 2 }, universe_map=UniverseMap { universes: [U0, U1] }
    get_or_create_table_for_ucanonical_goal{goal=UCanonical { canonical: Canonical { value: InEnvironment { environment: Env([]), goal: WellFormed(!1_0: Eq<!1_0>) }, binders: [] }, universes: 2 }}
      0ms INFO creating new table with goal = UCanonical {
          canonical: Canonical {
              value: InEnvironment {
                  environment: Env([]),
                  goal: WellFormed(!1_0: Eq<!1_0>),
              },
              binders: [],
          },
          universes: 2,
      }, table=TableIndex(1)
      0ms DEBUG created new universe: U1
      program_clauses_for_goal{environment=Env([]), goal=WellFormed(!1_0: Eq<!1_0>), binders=[]}
        program_clauses_that_could_match{goal=WellFormed(!1_0: Eq<!1_0>), binders=[]}
          push_binders{binders=for<type, type> []}
            0ms DEBUG value=[]
            0ms DEBUG pushed clause Some(for<type, type> WellFormed(^0.0: Eq<^0.1>) :- Implemented(^0.0: Eq<^0.1>))
            0ms DEBUG pushed clause Some(for<type, type> LocalImplAllowed(^0.0: Eq<^0.1>))
            0ms DEBUG pushed clause Some(for<type, type> Implemented(^0.0: Eq<^0.1>) :- FromEnv(^0.0: Eq<^0.1>))
        0ms DEBUG clauses=[for<type, type> WellFormed(^0.0: Eq<^0.1>) :- Implemented(^0.0: Eq<^0.1>)]
      0ms INFO program clause = for<type, type> WellFormed(^0.0: Eq<^0.1>) :- Implemented(^0.0: Eq<^0.1>)
      resolvent_clause{db=ChalkDatabase { }, goal=WellFormed(!1_0: Eq<!1_0>), clause=for<type, type> WellFormed(^0.0: Eq<^0.1>) :- Implemented(^0.0: Eq<^0.1>)}
        0ms DEBUG created new variable, var=?0, ui=U1
        0ms DEBUG created new variable, var=?1, ui=U1
        0ms DEBUG consequence=WellFormed(?0: Eq<?1>), conditions=(Implemented(?0: Eq<?1>)), constraints=[]
        relate{variance=Invariant, a=WellFormed(!1_0: Eq<!1_0>), b=WellFormed(?0: Eq<?1>)}
          relate{variance=Invariant, a=WellFormed(!1_0: Eq<!1_0>), b=WellFormed(?0: Eq<?1>)}
            0ms DEBUG zip_tys Invariant, !1_0, ?0
            relate_ty_ty{variance=Invariant, a=!1_0, b=?0}
              relate_var_ty{var=?0, ty=!1_0}
                0ms DEBUG relate_var_ty: universe index of var: U1
                0ms DEBUG trying fold_with on !1_0
                0ms DEBUG just generalizing to the ty itself: !1_0
                0ms DEBUG var ?0 generalized to !1_0
                0ms DEBUG var ?0 set to !1_0
                relate_ty_ty{variance=Invariant, a=!1_0, b=!1_0}
                0ms DEBUG generalized var !1_0 related to !1_0
            0ms DEBUG zip_tys Invariant, !1_0, ?1
            relate_ty_ty{variance=Invariant, a=!1_0, b=?1}
              relate_var_ty{var=?1, ty=!1_0}
                0ms DEBUG relate_var_ty: universe index of var: U1
                0ms DEBUG trying fold_with on !1_0
                0ms DEBUG just generalizing to the ty itself: !1_0
                0ms DEBUG var ?1 generalized to !1_0
                0ms DEBUG var ?1 set to !1_0
                relate_ty_ty{variance=Invariant, a=!1_0, b=!1_0}
                0ms DEBUG generalized var !1_0 related to !1_0
      2ms INFO pushing initial strand with ex-clause: ExClause {
          subst: [],
          ambiguous: false,
          constraints: [],
          subgoals: [
              Positive(
                  InEnvironment {
                      environment: Env([]),
                      goal: Implemented(?0: Eq<?1>),
                  },
              ),
          ],
          delayed_subgoals: [],
          answer_time: TimeStamp {
              clock: 0,
          },
          floundered_subgoals: [],
      }
      canonicalize{message=ExClause {
          subst: [],
          ambiguous: false,
          constraints: [],
          subgoals: [
              Positive(
                  InEnvironment {
                      environment: Env([]),
                      goal: Implemented(?0: Eq<?1>),
                  },
              ),
          ],
          delayed_subgoals: [],
          answer_time: TimeStamp {
              clock: 0,
          },
          floundered_subgoals: [],
      }}
        fold_inference_ty{var=?0, kind=General, outer_binder=^0}
          0ms DEBUG bound to !1_0
        fold_inference_ty{var=?1, kind=General, outer_binder=^0}
          0ms DEBUG bound to !1_0
  3ms DEBUG table selection TableIndex(1) with goal: UCanonical { canonical: Canonical { value: InEnvironment { environment: Env([]), goal: WellFormed(!1_0: Eq<!1_0>) }, binders: [] }, universes: 2 }, subgoal_table=TableIndex(1), goal=UCanonical { canonical: Canonical { value: InEnvironment { environment: Env([]), goal: WellFormed(!1_0: Eq<!1_0>) }, binders: [] }, universes: 2 }
  3ms DEBUG created new universe: U1
  3ms DEBUG created new universe: U1
  3ms DEBUG starting next strand = Strand {
      ex_clause: ExClause {
          subst: [],
          ambiguous: false,
          constraints: [],
          subgoals: [
              Positive(
                  InEnvironment {
                      environment: Env([]),
                      goal: Implemented(!1_0: Eq<!1_0>),
                  },
              ),
          ],
          delayed_subgoals: [],
          answer_time: TimeStamp {
              clock: 0,
          },
          floundered_subgoals: [],
      },
      selected_subgoal: None,
  }
  get_or_create_table_for_subgoal{subgoal=Positive(InEnvironment { environment: Env([]), goal: Implemented(!1_0: Eq<!1_0>) })}
    canonicalize{message=InEnvironment {
        environment: Env([]),
        goal: Implemented(!1_0: Eq<!1_0>),
    }}
    u_canonicalize{message=Canonical {
        value: InEnvironment {
            environment: Env([]),
            goal: Implemented(!1_0: Eq<!1_0>),
        },
        binders: [],
    }}
    0ms DEBUG ucanonical_subgoal=UCanonical { canonical: Canonical { value: InEnvironment { environment: Env([]), goal: Implemented(!1_0: Eq<!1_0>) }, binders: [] }, universes: 2 }, universe_map=UniverseMap { universes: [U0, U1] }
    get_or_create_table_for_ucanonical_goal{goal=UCanonical { canonical: Canonical { value: InEnvironment { environment: Env([]), goal: Implemented(!1_0: Eq<!1_0>) }, binders: [] }, universes: 2 }}
      0ms INFO creating new table with goal = UCanonical {
          canonical: Canonical {
              value: InEnvironment {
                  environment: Env([]),
                  goal: Implemented(!1_0: Eq<!1_0>),
              },
              binders: [],
          },
          universes: 2,
      }, table=TableIndex(2)
      0ms DEBUG created new universe: U1
      program_clauses_for_goal{environment=Env([]), goal=Implemented(!1_0: Eq<!1_0>), binders=[]}
        program_clauses_that_could_match{goal=Implemented(!1_0: Eq<!1_0>), binders=[]}
          push_binders{binders=for<type, type> []}
            0ms DEBUG value=[]
            0ms DEBUG pushed clause Some(for<type, type> WellFormed(^0.0: Eq<^0.1>) :- Implemented(^0.0: Eq<^0.1>))
            0ms DEBUG pushed clause Some(for<type, type> LocalImplAllowed(^0.0: Eq<^0.1>))
            0ms DEBUG pushed clause Some(for<type, type> Implemented(^0.0: Eq<^0.1>) :- FromEnv(^0.0: Eq<^0.1>))
          push_binders{binders=for<type> (^0.0 as Eq<^0.0>, [])}
            0ms DEBUG value=(^0.0 as Eq<^0.0>, [])
            0ms DEBUG pushed clause Some(for<type> Implemented(^0.0: Eq<^0.0>))
        0ms DEBUG clauses=[for<type, type> Implemented(^0.0: Eq<^0.1>) :- FromEnv(^0.0: Eq<^0.1>), for<type> Implemented(^0.0: Eq<^0.0>)]
      1ms INFO program clause = for<type, type> Implemented(^0.0: Eq<^0.1>) :- FromEnv(^0.0: Eq<^0.1>)
      resolvent_clause{db=ChalkDatabase { }, goal=Implemented(!1_0: Eq<!1_0>), clause=for<type, type> Implemented(^0.0: Eq<^0.1>) :- FromEnv(^0.0: Eq<^0.1>)}
        0ms DEBUG created new variable, var=?0, ui=U1
        0ms DEBUG created new variable, var=?1, ui=U1
        0ms DEBUG consequence=Implemented(?0: Eq<?1>), conditions=(FromEnv(?0: Eq<?1>)), constraints=[]
        relate{variance=Invariant, a=Implemented(!1_0: Eq<!1_0>), b=Implemented(?0: Eq<?1>)}
          relate{variance=Invariant, a=Implemented(!1_0: Eq<!1_0>), b=Implemented(?0: Eq<?1>)}
            0ms DEBUG zip_tys Invariant, !1_0, ?0
            relate_ty_ty{variance=Invariant, a=!1_0, b=?0}
              relate_var_ty{var=?0, ty=!1_0}
                0ms DEBUG relate_var_ty: universe index of var: U1
                0ms DEBUG trying fold_with on !1_0
                0ms DEBUG just generalizing to the ty itself: !1_0
                0ms DEBUG var ?0 generalized to !1_0
                0ms DEBUG var ?0 set to !1_0
                relate_ty_ty{variance=Invariant, a=!1_0, b=!1_0}
                0ms DEBUG generalized var !1_0 related to !1_0
            0ms DEBUG zip_tys Invariant, !1_0, ?1
            relate_ty_ty{variance=Invariant, a=!1_0, b=?1}
              relate_var_ty{var=?1, ty=!1_0}
                0ms DEBUG relate_var_ty: universe index of var: U1
                0ms DEBUG trying fold_with on !1_0
                0ms DEBUG just generalizing to the ty itself: !1_0
                0ms DEBUG var ?1 generalized to !1_0
                0ms DEBUG var ?1 set to !1_0
                relate_ty_ty{variance=Invariant, a=!1_0, b=!1_0}
                0ms DEBUG generalized var !1_0 related to !1_0
      2ms INFO pushing initial strand with ex-clause: ExClause {
          subst: [],
          ambiguous: false,
          constraints: [],
          subgoals: [
              Positive(
                  InEnvironment {
                      environment: Env([]),
                      goal: FromEnv(?0: Eq<?1>),
                  },
              ),
          ],
          delayed_subgoals: [],
          answer_time: TimeStamp {
              clock: 0,
          },
          floundered_subgoals: [],
      }
      canonicalize{message=ExClause {
          subst: [],
          ambiguous: false,
          constraints: [],
          subgoals: [
              Positive(
                  InEnvironment {
                      environment: Env([]),
                      goal: FromEnv(?0: Eq<?1>),
                  },
              ),
          ],
          delayed_subgoals: [],
          answer_time: TimeStamp {
              clock: 0,
          },
          floundered_subgoals: [],
      }}
        fold_inference_ty{var=?0, kind=General, outer_binder=^0}
          0ms DEBUG bound to !1_0
        fold_inference_ty{var=?1, kind=General, outer_binder=^0}
          0ms DEBUG bound to !1_0
      2ms INFO program clause = for<type> Implemented(^0.0: Eq<^0.0>)
      resolvent_clause{db=ChalkDatabase { }, goal=Implemented(!1_0: Eq<!1_0>), clause=for<type> Implemented(^0.0: Eq<^0.0>)}
        0ms DEBUG created new variable, var=?0, ui=U1
        0ms DEBUG consequence=Implemented(?0: Eq<?0>), conditions=(), constraints=[]
        relate{variance=Invariant, a=Implemented(!1_0: Eq<!1_0>), b=Implemented(?0: Eq<?0>)}
          relate{variance=Invariant, a=Implemented(!1_0: Eq<!1_0>), b=Implemented(?0: Eq<?0>)}
            0ms DEBUG zip_tys Invariant, !1_0, ?0
            relate_ty_ty{variance=Invariant, a=!1_0, b=?0}
              relate_var_ty{var=?0, ty=!1_0}
                0ms DEBUG relate_var_ty: universe index of var: U1
                0ms DEBUG trying fold_with on !1_0
                0ms DEBUG just generalizing to the ty itself: !1_0
                0ms DEBUG var ?0 generalized to !1_0
                0ms DEBUG var ?0 set to !1_0
                relate_ty_ty{variance=Invariant, a=!1_0, b=!1_0}
                0ms DEBUG generalized var !1_0 related to !1_0
            0ms DEBUG zip_tys Invariant, !1_0, ?0
            relate_ty_ty{variance=Invariant, a=!1_0, b=!1_0}
      3ms INFO pushing initial strand with ex-clause: ExClause {
          subst: [],
          ambiguous: false,
          constraints: [],
          subgoals: [],
          delayed_subgoals: [],
          answer_time: TimeStamp {
              clock: 0,
          },
          floundered_subgoals: [],
      }
      canonicalize{message=ExClause {
          subst: [],
          ambiguous: false,
          constraints: [],
          subgoals: [],
          delayed_subgoals: [],
          answer_time: TimeStamp {
              clock: 0,
          },
          floundered_subgoals: [],
      }}
  7ms DEBUG table selection TableIndex(2) with goal: UCanonical { canonical: Canonical { value: InEnvironment { environment: Env([]), goal: Implemented(!1_0: Eq<!1_0>) }, binders: [] }, universes: 2 }, subgoal_table=TableIndex(2), goal=UCanonical { canonical: Canonical { value: InEnvironment { environment: Env([]), goal: Implemented(!1_0: Eq<!1_0>) }, binders: [] }, universes: 2 }
  7ms DEBUG created new universe: U1
  7ms DEBUG created new universe: U1
  7ms DEBUG starting next strand = Strand {
      ex_clause: ExClause {
          subst: [],
          ambiguous: false,
          constraints: [],
          subgoals: [
              Positive(
                  InEnvironment {
                      environment: Env([]),
                      goal: FromEnv(!1_0: Eq<!1_0>),
                  },
              ),
          ],
          delayed_subgoals: [],
          answer_time: TimeStamp {
              clock: 0,
          },
          floundered_subgoals: [],
      },
      selected_subgoal: None,
  }
  get_or_create_table_for_subgoal{subgoal=Positive(InEnvironment { environment: Env([]), goal: FromEnv(!1_0: Eq<!1_0>) })}
    canonicalize{message=InEnvironment {
        environment: Env([]),
        goal: FromEnv(!1_0: Eq<!1_0>),
    }}
    u_canonicalize{message=Canonical {
        value: InEnvironment {
            environment: Env([]),
            goal: FromEnv(!1_0: Eq<!1_0>),
        },
        binders: [],
    }}
    0ms DEBUG ucanonical_subgoal=UCanonical { canonical: Canonical { value: InEnvironment { environment: Env([]), goal: FromEnv(!1_0: Eq<!1_0>) }, binders: [] }, universes: 2 }, universe_map=UniverseMap { universes: [U0, U1] }
    get_or_create_table_for_ucanonical_goal{goal=UCanonical { canonical: Canonical { value: InEnvironment { environment: Env([]), goal: FromEnv(!1_0: Eq<!1_0>) }, binders: [] }, universes: 2 }}
      0ms INFO creating new table with goal = UCanonical {
          canonical: Canonical {
              value: InEnvironment {
                  environment: Env([]),
                  goal: FromEnv(!1_0: Eq<!1_0>),
              },
              binders: [],
          },
          universes: 2,
      }, table=TableIndex(3)
      0ms DEBUG created new universe: U1
      program_clauses_for_goal{environment=Env([]), goal=FromEnv(!1_0: Eq<!1_0>), binders=[]}
        program_clauses_that_could_match{goal=FromEnv(!1_0: Eq<!1_0>), binders=[]}
        0ms DEBUG clauses=[]
  8ms DEBUG table selection TableIndex(3) with goal: UCanonical { canonical: Canonical { value: InEnvironment { environment: Env([]), goal: FromEnv(!1_0: Eq<!1_0>) }, binders: [] }, universes: 2 }, subgoal_table=TableIndex(3), goal=UCanonical { canonical: Canonical { value: InEnvironment { environment: Env([]), goal: FromEnv(!1_0: Eq<!1_0>) }, binders: [] }, universes: 2 }
  8ms DEBUG no more strands available (or all cycles) for TableIndex(3)
  8ms DEBUG no more strands available
  8ms DEBUG discarding strand because positive literal
  canonicalize{message=ExClause {
      subst: [],
      ambiguous: false,
      constraints: [],
      subgoals: [
          Positive(
              InEnvironment {
                  environment: Env([]),
                  goal: Implemented(!1_0: Eq<!1_0>),
              },
          ),
      ],
      delayed_subgoals: [],
      answer_time: TimeStamp {
          clock: 0,
      },
      floundered_subgoals: [],
  }}
  canonicalize{message=ExClause {
      subst: [],
      ambiguous: false,
      constraints: [],
      subgoals: [
          Positive(
              InEnvironment {
                  environment: Env([]),
                  goal: WellFormed(!1_0: Eq<!1_0>),
              },
          ),
      ],
      delayed_subgoals: [],
      answer_time: TimeStamp {
          clock: 0,
      },
      floundered_subgoals: [],
  }}
ensure_root_answer{initial_table=TableIndex(0), initial_answer=AnswerIndex(0)}
  0ms INFO table goal = UCanonical {
      canonical: Canonical {
          value: InEnvironment {
              environment: Env([]),
              goal: ForAll<type> { if ([]) { WellFormed(^0.0: Eq<^0.0>) } },
          },
          binders: [],
      },
      universes: 1,
  }
  0ms DEBUG starting next strand = Strand {
      ex_clause: ExClause {
          subst: [],
          ambiguous: false,
          constraints: [],
          subgoals: [
              Positive(
                  InEnvironment {
                      environment: Env([]),
                      goal: WellFormed(!1_0: Eq<!1_0>),
                  },
              ),
          ],
          delayed_subgoals: [],
          answer_time: TimeStamp {
              clock: 0,
          },
          floundered_subgoals: [],
      },
      selected_subgoal: Some(
          SelectedSubgoal {
              subgoal_index: 0,
              subgoal_table: TableIndex(1),
              answer_index: AnswerIndex(0),
              universe_map: UniverseMap {
                  universes: [
                      U0,
                      U1,
                  ],
              },
          },
      ),
  }
  0ms DEBUG table selection TableIndex(1) with goal: UCanonical { canonical: Canonical { value: InEnvironment { environment: Env([]), goal: WellFormed(!1_0: Eq<!1_0>) }, binders: [] }, universes: 2 }, subgoal_table=TableIndex(1), goal=UCanonical { canonical: Canonical { value: InEnvironment { environment: Env([]), goal: WellFormed(!1_0: Eq<!1_0>) }, binders: [] }, universes: 2 }
  0ms DEBUG created new universe: U1
  0ms DEBUG created new universe: U1
  0ms DEBUG starting next strand = Strand {
      ex_clause: ExClause {
          subst: [],
          ambiguous: false,
          constraints: [],
          subgoals: [
              Positive(
                  InEnvironment {
                      environment: Env([]),
                      goal: Implemented(!1_0: Eq<!1_0>),
                  },
              ),
          ],
          delayed_subgoals: [],
          answer_time: TimeStamp {
              clock: 0,
          },
          floundered_subgoals: [],
      },
      selected_subgoal: Some(
          SelectedSubgoal {
              subgoal_index: 0,
              subgoal_table: TableIndex(2),
              answer_index: AnswerIndex(0),
              universe_map: UniverseMap {
                  universes: [
                      U0,
                      U1,
                  ],
              },
          },
      ),
  }
  0ms DEBUG table selection TableIndex(2) with goal: UCanonical { canonical: Canonical { value: InEnvironment { environment: Env([]), goal: Implemented(!1_0: Eq<!1_0>) }, binders: [] }, universes: 2 }, subgoal_table=TableIndex(2), goal=UCanonical { canonical: Canonical { value: InEnvironment { environment: Env([]), goal: Implemented(!1_0: Eq<!1_0>) }, binders: [] }, universes: 2 }
  0ms DEBUG created new universe: U1
  0ms DEBUG created new universe: U1
  0ms DEBUG starting next strand = Strand {
      ex_clause: ExClause {
          subst: [],
          ambiguous: false,
          constraints: [],
          subgoals: [],
          delayed_subgoals: [],
          answer_time: TimeStamp {
              clock: 0,
          },
          floundered_subgoals: [],
      },
      selected_subgoal: None,
  }
  0ms DEBUG no remaining subgoals for the table
  canonicalize{message=AnswerSubst {
      subst: [],
      constraints: [],
      delayed_subgoals: [],
  }}
  0ms DEBUG found answer, table=TableIndex(2), subst=Canonical { value: AnswerSubst { subst: [], constraints: [], delayed_subgoals: [] }, binders: [] }, floundered=false
  push_answer{answer=Answer { subst: Canonical { value: AnswerSubst { subst: [], constraints: [], delayed_subgoals: [] }, binders: [] }, ambiguous: false }}
    0ms DEBUG pre-existing entry: None
    0ms INFO new answer to table, goal=UCanonical { canonical: Canonical { value: InEnvironment { environment: Env([]), goal: Implemented(!1_0: Eq<!1_0>) }, binders: [] }, universes: 2 }, answer=Answer { subst: Canonical { value: AnswerSubst { subst: [], constraints: [], delayed_subgoals: [] }, binders: [] }, ambiguous: false }
  1ms DEBUG answer is available
  1ms DEBUG starting next strand = Strand {
      ex_clause: ExClause {
          subst: [],
          ambiguous: false,
          constraints: [],
          subgoals: [
              Positive(
                  InEnvironment {
                      environment: Env([]),
                      goal: Implemented(!1_0: Eq<!1_0>),
                  },
              ),
          ],
          delayed_subgoals: [],
          answer_time: TimeStamp {
              clock: 0,
          },
          floundered_subgoals: [],
      },
      selected_subgoal: Some(
          SelectedSubgoal {
              subgoal_index: 0,
              subgoal_table: TableIndex(2),
              answer_index: AnswerIndex(0),
              universe_map: UniverseMap {
                  universes: [
                      U0,
                      U1,
                  ],
              },
          },
      ),
  }
  1ms DEBUG table selection TableIndex(2) with goal: UCanonical { canonical: Canonical { value: InEnvironment { environment: Env([]), goal: Implemented(!1_0: Eq<!1_0>) }, binders: [] }, universes: 2 }, subgoal_table=TableIndex(2), goal=UCanonical { canonical: Canonical { value: InEnvironment { environment: Env([]), goal: Implemented(!1_0: Eq<!1_0>) }, binders: [] }, universes: 2 }
  1ms INFO answer cached = Answer { subst: Canonical { value: AnswerSubst { subst: [], constraints: [], delayed_subgoals: [] }, binders: [] }, ambiguous: false }
  map_from_canonical{canonical_value=Canonical { value: InEnvironment { environment: Env([]), goal: Implemented(!1_0: Eq<!1_0>) }, binders: [] }, universes=[U0, U1]}
  map_from_canonical{canonical_value=Canonical { value: AnswerSubst { subst: [], constraints: [], delayed_subgoals: [] }, binders: [] }, universes=[U0, U1]}
  apply_answer_subst{unification_database=ChalkDatabase { }, ex_clause=ExClause { subst: [], ambiguous: false, constraints: [], subgoals: [], delayed_subgoals: [], answer_time: TimeStamp { clock: 0 }, floundered_subgoals: [] }, selected_goal=InEnvironment { environment: Env([]), goal: Implemented(!1_0: Eq<!1_0>) }, answer_table_goal=Canonical { value: InEnvironment { environment: Env([]), goal: Implemented(!1_0: Eq<!1_0>) }, binders: [] }, canonical_answer_subst=Canonical { value: AnswerSubst { subst: [], constraints: [], delayed_subgoals: [] }, binders: [] }}
    0ms DEBUG selected_goal=InEnvironment { environment: Env([]), goal: Implemented(!1_0: Eq<!1_0>) }
  1ms DEBUG merged answer into current strand, strand=Strand { ex_clause: ExClause { subst: [], ambiguous: false, constraints: [], subgoals: [], delayed_subgoals: [], answer_time: TimeStamp { clock: 1 }, floundered_subgoals: [] }, selected_subgoal: None }
  1ms DEBUG starting next strand = Strand {
      ex_clause: ExClause {
          subst: [],
          ambiguous: false,
          constraints: [],
          subgoals: [],
          delayed_subgoals: [],
          answer_time: TimeStamp {
              clock: 1,
          },
          floundered_subgoals: [],
      },
      selected_subgoal: None,
  }
  1ms DEBUG no remaining subgoals for the table
  canonicalize{message=AnswerSubst {
      subst: [],
      constraints: [],
      delayed_subgoals: [],
  }}
  1ms DEBUG found answer, table=TableIndex(1), subst=Canonical { value: AnswerSubst { subst: [], constraints: [], delayed_subgoals: [] }, binders: [] }, floundered=false
  push_answer{answer=Answer { subst: Canonical { value: AnswerSubst { subst: [], constraints: [], delayed_subgoals: [] }, binders: [] }, ambiguous: false }}
    0ms DEBUG pre-existing entry: None
    0ms INFO new answer to table, goal=UCanonical { canonical: Canonical { value: InEnvironment { environment: Env([]), goal: WellFormed(!1_0: Eq<!1_0>) }, binders: [] }, universes: 2 }, answer=Answer { subst: Canonical { value: AnswerSubst { subst: [], constraints: [], delayed_subgoals: [] }, binders: [] }, ambiguous: false }
  2ms DEBUG answer is available
  2ms DEBUG starting next strand = Strand {
      ex_clause: ExClause {
          subst: [],
          ambiguous: false,
          constraints: [],
          subgoals: [
              Positive(
                  InEnvironment {
                      environment: Env([]),
                      goal: WellFormed(!1_0: Eq<!1_0>),
                  },
              ),
          ],
          delayed_subgoals: [],
          answer_time: TimeStamp {
              clock: 0,
          },
          floundered_subgoals: [],
      },
      selected_subgoal: Some(
          SelectedSubgoal {
              subgoal_index: 0,
              subgoal_table: TableIndex(1),
              answer_index: AnswerIndex(0),
              universe_map: UniverseMap {
                  universes: [
                      U0,
                      U1,
                  ],
              },
          },
      ),
  }
  2ms DEBUG table selection TableIndex(1) with goal: UCanonical { canonical: Canonical { value: InEnvironment { environment: Env([]), goal: WellFormed(!1_0: Eq<!1_0>) }, binders: [] }, universes: 2 }, subgoal_table=TableIndex(1), goal=UCanonical { canonical: Canonical { value: InEnvironment { environment: Env([]), goal: WellFormed(!1_0: Eq<!1_0>) }, binders: [] }, universes: 2 }
  2ms INFO answer cached = Answer { subst: Canonical { value: AnswerSubst { subst: [], constraints: [], delayed_subgoals: [] }, binders: [] }, ambiguous: false }
  map_from_canonical{canonical_value=Canonical { value: InEnvironment { environment: Env([]), goal: WellFormed(!1_0: Eq<!1_0>) }, binders: [] }, universes=[U0, U1]}
  map_from_canonical{canonical_value=Canonical { value: AnswerSubst { subst: [], constraints: [], delayed_subgoals: [] }, binders: [] }, universes=[U0, U1]}
  apply_answer_subst{unification_database=ChalkDatabase { }, ex_clause=ExClause { subst: [], ambiguous: false, constraints: [], subgoals: [], delayed_subgoals: [], answer_time: TimeStamp { clock: 0 }, floundered_subgoals: [] }, selected_goal=InEnvironment { environment: Env([]), goal: WellFormed(!1_0: Eq<!1_0>) }, answer_table_goal=Canonical { value: InEnvironment { environment: Env([]), goal: WellFormed(!1_0: Eq<!1_0>) }, binders: [] }, canonical_answer_subst=Canonical { value: AnswerSubst { subst: [], constraints: [], delayed_subgoals: [] }, binders: [] }}
    0ms DEBUG selected_goal=InEnvironment { environment: Env([]), goal: WellFormed(!1_0: Eq<!1_0>) }
  2ms DEBUG merged answer into current strand, strand=Strand { ex_clause: ExClause { subst: [], ambiguous: false, constraints: [], subgoals: [], delayed_subgoals: [], answer_time: TimeStamp { clock: 1 }, floundered_subgoals: [] }, selected_subgoal: None }
  2ms DEBUG starting next strand = Strand {
      ex_clause: ExClause {
          subst: [],
          ambiguous: false,
          constraints: [],
          subgoals: [],
          delayed_subgoals: [],
          answer_time: TimeStamp {
              clock: 1,
          },
          floundered_subgoals: [],
      },
      selected_subgoal: None,
  }
  2ms DEBUG no remaining subgoals for the table
  canonicalize{message=AnswerSubst {
      subst: [],
      constraints: [],
      delayed_subgoals: [],
  }}
  2ms DEBUG found answer, table=TableIndex(0), subst=Canonical { value: AnswerSubst { subst: [], constraints: [], delayed_subgoals: [] }, binders: [] }, floundered=false
  push_answer{answer=Answer { subst: Canonical { value: AnswerSubst { subst: [], constraints: [], delayed_subgoals: [] }, binders: [] }, ambiguous: false }}
    0ms DEBUG pre-existing entry: None
    0ms INFO new answer to table, goal=UCanonical { canonical: Canonical { value: InEnvironment { environment: Env([]), goal: ForAll<type> { if ([]) { WellFormed(^0.0: Eq<^0.0>) } } }, binders: [] }, universes: 1 }, answer=Answer { subst: Canonical { value: AnswerSubst { subst: [], constraints: [], delayed_subgoals: [] }, binders: [] }, ambiguous: false }
  3ms DEBUG answer is available
DEBUG answer=CompleteAnswer { subst: Canonical { value: ConstrainedSubst { subst: [], constraints: [] }, binders: [] }, ambiguous: false }
ensure_root_answer{initial_table=TableIndex(0), initial_answer=AnswerIndex(1)}
  0ms INFO table goal = UCanonical {
      canonical: Canonical {
          value: InEnvironment {
              environment: Env([]),
              goal: ForAll<type> { if ([]) { WellFormed(^0.0: Eq<^0.0>) } },
          },
          binders: [],
      },
      universes: 1,
  }
  0ms DEBUG no more strands available (or all cycles) for TableIndex(0)
  0ms DEBUG no more strands available
  0ms DEBUG no more solutions
DEBUG created new universe: U1
DEBUG created new universe: U2
canonicalize{message=InEnvironment {
    environment: Env([]),
    goal: Implemented(dyn for<type> [for<> Implemented(^1.0: Foo)] + '!1_0: Eq<dyn for<type> [for<> Implemented(^1.0: Foo)] + '!2_0>),
}}
u_canonicalize{message=Canonical {
    value: InEnvironment {
        environment: Env([]),
        goal: Implemented(dyn for<type> [for<> Implemented(^1.0: Foo)] + '!1_0: Eq<dyn for<type> [for<> Implemented(^1.0: Foo)] + '!2_0>),
    },
    binders: [],
}}
get_or_create_table_for_ucanonical_goal{goal=UCanonical { canonical: Canonical { value: InEnvironment { environment: Env([]), goal: Implemented(dyn for<type> [for<> Implemented(^1.0: Foo)] + '!1_0: Eq<dyn for<type> [for<> Implemented(^1.0: Foo)] + '!2_0>) }, binders: [] }, universes: 3 }}
  0ms INFO creating new table with goal = UCanonical {
      canonical: Canonical {
          value: InEnvironment {
              environment: Env([]),
              goal: Implemented(dyn for<type> [for<> Implemented(^1.0: Foo)] + '!1_0: Eq<dyn for<type> [for<> Implemented(^1.0: Foo)] + '!2_0>),
          },
          binders: [],
      },
      universes: 3,
  }, table=TableIndex(0)
  0ms DEBUG created new universe: U1
  0ms DEBUG created new universe: U2
  program_clauses_for_goal{environment=Env([]), goal=Implemented(dyn for<type> [for<> Implemented(^1.0: Foo)] + '!1_0: Eq<dyn for<type> [for<> Implemented(^1.0: Foo)] + '!2_0>), binders=[]}
    program_clauses_that_could_match{goal=Implemented(dyn for<type> [for<> Implemented(^1.0: Foo)] + '!1_0: Eq<dyn for<type> [for<> Implemented(^1.0: Foo)] + '!2_0>), binders=[]}
      push_binders{binders=for<type, type> []}
        0ms DEBUG value=[]
        0ms DEBUG pushed clause Some(for<type, type> WellFormed(^0.0: Eq<^0.1>) :- Implemented(^0.0: Eq<^0.1>))
        0ms DEBUG pushed clause Some(for<type, type> LocalImplAllowed(^0.0: Eq<^0.1>))
        0ms DEBUG pushed clause Some(for<type, type> Implemented(^0.0: Eq<^0.1>) :- FromEnv(^0.0: Eq<^0.1>))
      push_binders{binders=for<type> (^0.0 as Eq<^0.0>, [])}
        0ms DEBUG value=(^0.0 as Eq<^0.0>, [])
        0ms DEBUG pushed clause Some(for<type> Implemented(^0.0: Eq<^0.0>))
      push_binders{binders=for<> dyn for<type> [for<> Implemented(^1.0: Foo)] + '!1_0}
        0ms DEBUG value=dyn for<type> [for<> Implemented(^1.0: Foo)] + '!1_0
        push_binders{binders=for<> Implemented(dyn for<type> [for<> Implemented(^1.0: Foo)] + '!1_0: Foo)}
          0ms DEBUG value=Implemented(dyn for<type> [for<> Implemented(^1.0: Foo)] + '!1_0: Foo)
          push_binders{binders=for<> dyn for<type> [for<> Implemented(^1.0: Foo)] + '!1_0 as Foo}
            0ms DEBUG value=dyn for<type> [for<> Implemented(^1.0: Foo)] + '!1_0 as Foo
            0ms DEBUG pushed clause Some(for<> Implemented(dyn for<type> [for<> Implemented(^1.0: Foo)] + '!1_0: Foo))
    1ms DEBUG clauses=[for<type, type> Implemented(^0.0: Eq<^0.1>) :- FromEnv(^0.0: Eq<^0.1>), for<type> Implemented(^0.0: Eq<^0.0>)]
  1ms INFO program clause = for<type, type> Implemented(^0.0: Eq<^0.1>) :- FromEnv(^0.0: Eq<^0.1>)
  resolvent_clause{db=ChalkDatabase { }, goal=Implemented(dyn for<type> [for<> Implemented(^1.0: Foo)] + '!1_0: Eq<dyn for<type> [for<> Implemented(^1.0: Foo)] + '!2_0>), clause=for<type, type> Implemented(^0.0: Eq<^0.1>) :- FromEnv(^0.0: Eq<^0.1>)}
    0ms DEBUG created new variable, var=?0, ui=U2
    0ms DEBUG created new variable, var=?1, ui=U2
    0ms DEBUG consequence=Implemented(?0: Eq<?1>), conditions=(FromEnv(?0: Eq<?1>)), constraints=[]
    relate{variance=Invariant, a=Implemented(dyn for<type> [for<> Implemented(^1.0: Foo)] + '!1_0: Eq<dyn for<type> [for<> Implemented(^1.0: Foo)] + '!2_0>), b=Implemented(?0: Eq<?1>)}
      relate{variance=Invariant, a=Implemented(dyn for<type> [for<> Implemented(^1.0: Foo)] + '!1_0: Eq<dyn for<type> [for<> Implemented(^1.0: Foo)] + '!2_0>), b=Implemented(?0: Eq<?1>)}
        0ms DEBUG zip_tys Invariant, dyn for<type> [for<> Implemented(^1.0: Foo)] + '!1_0, ?0
        relate_ty_ty{variance=Invariant, a=dyn for<type> [for<> Implemented(^1.0: Foo)] + '!1_0, b=?0}
          relate_var_ty{var=?0, ty=dyn for<type> [for<> Implemented(^1.0: Foo)] + '!1_0}
            0ms DEBUG relate_var_ty: universe index of var: U2
            0ms DEBUG trying fold_with on dyn for<type> [for<> Implemented(^1.0: Foo)] + '!1_0
            fold_free_placeholder_lifetime{ui=!1_0, _outer_binder=^0}
              fold_free_placeholder_lifetime{ui=!1_0, _outer_binder=^0}
            0ms DEBUG created new variable, var=?2, ui=U2
            generalize_substitution{substitution=[?0 := ^1.0], universe_index=U2}
              0ms DEBUG created new variable, var=?3, ui=U2
              relate_ty_ty{variance=Invariant, a=^1.0, b=?3}
test test::existential_types::dyn_lifetime_bound ... FAILED

failures:

---- test::existential_types::dyn_lifetime_bound stdout ----
program { trait Foo { } trait Eq < A > { } impl < A > Eq < A > for A { } }
----------------------------------------------------------------------
goal { forall < 'a > { forall < 'b > { dyn Foo + 'a : Eq < dyn Foo + 'b > } } }
using solver: SLG { max_size: 10, expected_answers: None }
thread 'test::existential_types::dyn_lifetime_bound' panicked at 'unification encountered bound variable: a=^1.0 b=?3', /home/daboross/proj/rust/chalk/chalk-solve/src/infer/unify.rs:206:68
stack backtrace:
   0: rust_begin_unwind
             at /rustc/623fb90b5a1f324e0ec44085116bf858cef19a00/library/std/src/panicking.rs:483
   1: std::panicking::begin_panic_fmt
             at /rustc/623fb90b5a1f324e0ec44085116bf858cef19a00/library/std/src/panicking.rs:437
   2: chalk_solve::infer::unify::Unifier<I>::relate_ty_ty
             at ./chalk-solve/src/infer/unify.rs:206
   3: chalk_solve::infer::unify::Unifier<I>::generalize_substitution::{{closure}}
             at ./chalk-solve/src/infer/unify.rs:349
   4: core::iter::adapters::map_try_fold::{{closure}}
             at /home/daboross/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/mod.rs:902
   5: core::iter::traits::iterator::Iterator::try_fold
             at /home/daboross/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/iterator.rs:1855
   6: <core::iter::adapters::Map<I,F> as core::iter::traits::iterator::Iterator>::try_fold
             at /home/daboross/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/mod.rs:928
   7: <core::iter::adapters::ResultShunt<I,E> as core::iter::traits::iterator::Iterator>::try_fold
             at /home/daboross/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/mod.rs:2939
   8: core::iter::traits::iterator::Iterator::find
             at /home/daboross/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/iterator.rs:2198
   9: <core::iter::adapters::ResultShunt<I,E> as core::iter::traits::iterator::Iterator>::next
             at /home/daboross/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/mod.rs:2921
  10: <alloc::vec::Vec<T> as alloc::vec::SpecFromIterNested<T,I>>::from_iter
             at /home/daboross/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec.rs:2124
  11: <alloc::vec::Vec<T> as alloc::vec::SpecFromIter<T,I>>::from_iter
             at /home/daboross/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec.rs:2161
  12: <alloc::vec::Vec<T> as core::iter::traits::collect::FromIterator<T>>::from_iter
             at /home/daboross/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec.rs:2001
  13: core::iter::traits::iterator::Iterator::collect
             at /home/daboross/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/iterator.rs:1637
  14: <core::result::Result<V,E> as core::iter::traits::collect::FromIterator<core::result::Result<A,E>>>::from_iter::{{closure}}
             at /home/daboross/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:1490
  15: core::iter::adapters::process_results
             at /home/daboross/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/mod.rs:2910
  16: <core::result::Result<V,E> as core::iter::traits::collect::FromIterator<core::result::Result<A,E>>>::from_iter
             at /home/daboross/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:1490
  17: core::iter::traits::iterator::Iterator::collect
             at /home/daboross/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/iterator.rs:1637
  18: chalk_solve::infer::unify::Unifier<I>::generalize_substitution
             at ./chalk-solve/src/infer/unify.rs:342
  19: chalk_solve::infer::unify::Unifier<I>::relate_var_ty::{{closure}}::{{closure}}::{{closure}}
             at ./chalk-solve/src/infer/unify.rs:468
  20: chalk_ir::Binders<T>::map
             at ./chalk-ir/src/lib.rs:1958
  21: chalk_ir::Binders<T>::map_ref
             at ./chalk-ir/src/lib.rs:1985
  22: chalk_solve::infer::unify::Unifier<I>::relate_var_ty::{{closure}}::{{closure}}
             at ./chalk-solve/src/infer/unify.rs:458
  23: core::ops::function::impls::<impl core::ops::function::FnOnce<A> for &mut F>::call_once
             at /home/daboross/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ops/function.rs:280
  24: core::option::Option<T>::map
             at /home/daboross/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/option.rs:450
  25: <core::iter::adapters::Map<I,F> as core::iter::traits::iterator::Iterator>::next
             at /home/daboross/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/mod.rs:914
  26: <core::iter::adapters::Map<I,F> as core::iter::traits::iterator::Iterator>::next
             at /home/daboross/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/mod.rs:914
  27: <chalk_ir::cast::Casted<IT,U> as core::iter::traits::iterator::Iterator>::next
             at ./chalk-ir/src/cast.rs:366
  28: core::iter::traits::iterator::Iterator::try_fold
             at /home/daboross/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/iterator.rs:1854
  29: <core::iter::adapters::ResultShunt<I,E> as core::iter::traits::iterator::Iterator>::try_fold
             at /home/daboross/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/mod.rs:2939
  30: core::iter::traits::iterator::Iterator::find
             at /home/daboross/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/iterator.rs:2198
  31: <core::iter::adapters::ResultShunt<I,E> as core::iter::traits::iterator::Iterator>::next
             at /home/daboross/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/mod.rs:2921
  32: <alloc::vec::Vec<T> as alloc::vec::SpecFromIterNested<T,I>>::from_iter
             at /home/daboross/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec.rs:2124
  33: <alloc::vec::Vec<T> as alloc::vec::SpecFromIter<T,I>>::from_iter
             at /home/daboross/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec.rs:2161
  34: <alloc::vec::Vec<T> as core::iter::traits::collect::FromIterator<T>>::from_iter
             at /home/daboross/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec.rs:2001
  35: core::iter::traits::iterator::Iterator::collect
             at /home/daboross/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/iterator.rs:1637
  36: <core::result::Result<V,E> as core::iter::traits::collect::FromIterator<core::result::Result<A,E>>>::from_iter::{{closure}}
             at /home/daboross/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:1490
  37: core::iter::adapters::process_results
             at /home/daboross/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/adapters/mod.rs:2910
  38: <core::result::Result<V,E> as core::iter::traits::collect::FromIterator<core::result::Result<A,E>>>::from_iter
             at /home/daboross/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/result.rs:1490
  39: core::iter::traits::iterator::Iterator::collect
             at /home/daboross/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/iter/traits/iterator.rs:1637
  40: <chalk_integration::interner::ChalkIr as chalk_ir::interner::Interner>::intern_quantified_where_clauses
             at ./chalk-integration/src/interner.rs:315
  41: chalk_ir::QuantifiedWhereClauses<I>::from_fallible
             at ./chalk-ir/src/lib.rs:2766
  42: chalk_ir::QuantifiedWhereClauses<I>::from_iter
             at ./chalk-ir/src/lib.rs:2780
  43: chalk_solve::infer::unify::Unifier<I>::relate_var_ty::{{closure}}
             at ./chalk-solve/src/infer/unify.rs:553
  44: chalk_ir::Binders<T>::map
             at ./chalk-ir/src/lib.rs:1958
  45: chalk_ir::Binders<T>::map_ref
             at ./chalk-ir/src/lib.rs:1985
  46: chalk_solve::infer::unify::Unifier<I>::relate_var_ty
             at ./chalk-solve/src/infer/unify.rs:455
  47: chalk_solve::infer::unify::Unifier<I>::relate_ty_ty
             at ./chalk-solve/src/infer/unify.rs:147
  48: <chalk_solve::infer::unify::Unifier<I> as chalk_ir::zip::Zipper<I>>::zip_tys
             at ./chalk-solve/src/infer/unify.rs:826
  49: <chalk_ir::Ty<I> as chalk_ir::zip::Zip<I>>::zip_with
             at ./chalk-ir/src/zip.rs:250
  50: chalk_ir::_DERIVE_chalk_ir_zip_Zip_I_FOR_GenericArgData::<impl chalk_ir::zip::Zip<I> for chalk_ir::GenericArgData<I>>::zip_with
             at ./chalk-ir/src/lib.rs:1368
  51: <chalk_ir::GenericArg<I> as chalk_ir::zip::Zip<I>>::zip_with
             at ./chalk-ir/src/zip.rs:485
  52: chalk_ir::zip::Zipper::zip_substs
             at ./chalk-ir/src/zip.rs:65
  53: <chalk_ir::TraitRef<I> as chalk_ir::zip::Zip<I>>::zip_with
             at ./chalk-ir/src/zip.rs:516
  54: chalk_ir::_DERIVE_chalk_ir_zip_Zip_I_FOR_WhereClause::<impl chalk_ir::zip::Zip<I> for chalk_ir::WhereClause<I>>::zip_with
             at ./chalk-ir/src/lib.rs:1575
  55: chalk_ir::_DERIVE_chalk_ir_zip_Zip_I_FOR_DomainGoal::<impl chalk_ir::zip::Zip<I> for chalk_ir::DomainGoal<I>>::zip_with
             at ./chalk-ir/src/lib.rs:1673
  56: chalk_solve::infer::unify::Unifier<I>::relate
             at ./chalk-solve/src/infer/unify.rs:78
  57: chalk_solve::infer::unify::<impl chalk_solve::infer::InferenceTable<I>>::relate
             at ./chalk-solve/src/infer/unify.rs:28
  58: chalk_engine::slg::resolvent::<impl chalk_engine::context::ResolventOps<I,chalk_engine::slg::SlgContext<I>> for chalk_engine::slg::TruncatingInferenceTable<I>>::resolvent_clause
             at ./chalk-engine/src/slg/resolvent.rs:91
  59: chalk_engine::logic::<impl chalk_engine::forest::Forest<I,C>>::build_table
             at ./chalk-engine/src/logic.rs:260
  60: chalk_engine::logic::<impl chalk_engine::forest::Forest<I,C>>::get_or_create_table_for_ucanonical_goal
             at ./chalk-engine/src/logic.rs:229
  61: chalk_engine::forest::Forest<I,C>::iter_answers
             at ./chalk-engine/src/forest.rs:46
  62: <chalk_engine::solve::SLGSolver<I> as chalk_solve::solve::Solver<I>>::solve
             at ./chalk-engine/src/solve.rs:40
  63: chalk_integration::db::ChalkDatabase::solve
             at ./chalk-integration/src/db.rs:54
  64: lib::test::solve_goal::{{closure}}::{{closure}}
             at ./tests/test/mod.rs:266
  65: chalk_integration::tls::set_current_program::{{closure}}
             at ./chalk-integration/src/tls.rs:166
  66: std::thread::local::LocalKey<T>::try_with
             at /home/daboross/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/local.rs:272
  67: std::thread::local::LocalKey<T>::with
             at /home/daboross/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/thread/local.rs:248
  68: chalk_integration::tls::set_current_program
             at ./chalk-integration/src/tls.rs:164
  69: lib::test::solve_goal::{{closure}}
             at ./tests/test/mod.rs:252
  70: tracing_core::dispatcher::with_default
             at /home/daboross/.cargo/registry/src/github.com-1ecc6299db9ec823/tracing-core-0.1.14/src/dispatcher.rs:230
  71: tracing::subscriber::with_default
             at /home/daboross/.cargo/registry/src/github.com-1ecc6299db9ec823/tracing-0.1.19/src/subscriber.rs:24
  72: chalk_solve::logging::with_tracing_logs
             at ./chalk-solve/src/logging.rs:11
  73: lib::test::solve_goal
             at ./tests/test/mod.rs:223
  74: lib::test::existential_types::dyn_lifetime_bound
             at ./tests/test/existential_types.rs:379
  75: lib::test::existential_types::dyn_lifetime_bound::{{closure}}
             at ./tests/test/existential_types.rs:378
  76: core::ops::function::FnOnce::call_once
             at /home/daboross/.rustup/toolchains/nightly-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ops/function.rs:227
  77: core::ops::function::FnOnce::call_once
             at /rustc/623fb90b5a1f324e0ec44085116bf858cef19a00/library/core/src/ops/function.rs:227
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.


failures:
    test::existential_types::dyn_lifetime_bound

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 435 filtered out

